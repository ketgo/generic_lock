// Copyright 2021 Ketan Goyal
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
//     http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.


/**
 * @brief Uint Test Generic Lock
 *
 */

#include <gtest/gtest.h>

#include <chrono>
#include <thread>
#include <tpl/locking/lock_guard.hpp>
#include <tpl/locking/record_lock.hpp>
#include <unordered_map>
#include <vector>

using namespace tpl;
using namespace std::chrono_literals;

class RecordLockTestFixture : public ::testing::Test {
 protected:
  static constexpr auto thread_sleep = 5ms;
  static constexpr size_t lock_wait_for_ms = 1;

  RecordLock<int, lock_wait_for_ms> record_lock;
  typedef LockGuard<int, lock_wait_for_ms> LockGuard;

  typedef std::unordered_map<int, char> Records;
  struct Op {
    Op(const TransactionId& txn_id = 0, const bool& write = false,
       const int& key = 0, const char& value = 0)
        : txn_id(txn_id), write(write), key(key), value(value) {}

    TransactionId txn_id;
    bool write;
    int key;
    char value;
  };
  typedef std::vector<Op> OpGroup;

  void SetUp() override {}
  void TearDown() override {}

 public:
  /**
   * @brief Run test in a thread by performing the given operation.
   *
   * @param op Constant reference to the operation to perform.
   * @param records Reference to the records to be operated.
   */
  void TestThreadLockUnlock(const Op& op, Records& records) {
    std::vector<LockGuard> guards;

    if (op.write) {
      guards.emplace_back(record_lock, op.txn_id, op.key);
      // Asserts that the lock request is successful.
      ASSERT_TRUE(guards.back());
      records[op.key] = op.value;
    } else {
      guards.emplace_back(record_lock, op.txn_id, op.key, true);
      ASSERT_EQ(records[op.key], op.value);
    }
    std::this_thread::sleep_for(thread_sleep);
  }

  /**
   * @brief Run test in a thread by performing the given operation.
   *
   * @param op_group Constant reference to the group of operations to perform.
   * @param records Reference to the records to be operated.
   */
  void TestThreadDeadlock(const OpGroup& op_group, Records& records) {
    std::vector<LockGuard> guards;

    for (auto& op : op_group) {
      if (op.write) {
        guards.emplace_back(record_lock, op.txn_id, op.key);
        // Check for the transaction and operation which causes deadlock.
        if (op.txn_id == 5 && op.key == 0) {
          // Asserts that the lock request is denied.
          ASSERT_FALSE(guards.back());
        } else {
          // Asserts that the lock request is successful.
          ASSERT_TRUE(guards.back());
        }
        records[op.key] = op.value;
      } else {
        guards.emplace_back(record_lock, op.txn_id, op.key, true);
        ASSERT_EQ(records[op.key], op.value);
      }
      std::this_thread::sleep_for(thread_sleep);
    }
  }
};

TEST_F(RecordLockTestFixture, TestLockUnlock) {
  Records records = {{0, 'a'}, {1, 'b'}};
  const std::vector<Op> ops = {
      {1, false, 0, 'a'},  {2, false, 0, 'a'},  {3, false, 1, 'b'},
      {4, true, 0, 'd'},   {5, false, 0, 'd'},  {6, false, 1, 'b'},
      {7, true, 0, 'a'},   {8, true, 1, 'e'},   {9, true, 0, 'f'},
      {10, false, 0, 'f'}, {11, false, 0, 'f'}, {12, false, 1, 'e'}};
  std::vector<std::thread> threads(ops.size());

  // Start threads
  for (size_t idx = 0; idx < ops.size(); ++idx) {
    threads[idx] = std::thread(&RecordLockTestFixture::TestThreadLockUnlock,
                               this, ops[idx], std::ref(records));
  }

  // Wait till all threads finish
  for (auto& thread : threads) {
    thread.join();
  }
}

TEST_F(RecordLockTestFixture, TestUnlockAll) {
  Records records = {{0, 'a'}, {1, 'b'}};
  TransactionId txn_id = 1;
  std::vector<std::thread> threads(2);

  // Start read threads
  threads[0] = std::thread([&]() {
    record_lock.Lock(txn_id, 0);
    records[0] = 'd';
    // NOTE: No unlock is deliberate
  });
  threads[1] = std::thread([&]() {
    record_lock.Lock(txn_id, 1);
    records[1] = 'e';
    // NOTE: No unlock is deliberate
  });

  // Wait till all the keys are locked
  while (!record_lock.IsLocked(0)) {
  }
  while (!record_lock.IsLocked(1)) {
  }

  // Unlock all held locks by the transaction
  record_lock.UnlockAll(txn_id);

  // Wait till all threads finish
  for (auto& thread : threads) {
    thread.join();
  }

  // Assert updated records
  ASSERT_EQ(records[0], 'd');
  ASSERT_EQ(records[1], 'e');
}

TEST_F(RecordLockTestFixture, TestDeadlock) {
  Records records = {{0, '0'}, {1, '1'}, {2, '2'}};
  // Transaction 5 causes deadlock with 2
  const std::vector<OpGroup> op_groups = {
      {{1, true, 0, 'a'}},
      {{2, true, 0, 'b'}, {2, true, 1, 'b'}, {2, true, 2, 'b'}},
      {{3, true, 0, 'd'}},
      {{4, true, 0, 'e'}, {4, true, 1, 'e'}},
      {{5, true, 1, 'f'}, {5, true, 0, 'f'}},
      {{6, true, 1, 'g'}},
      {{7, true, 1, 'h'}, {7, true, 2, 'h'}}};
  std::vector<std::thread> threads(op_groups.size());

  // Start threads
  for (size_t idx = 0; idx < op_groups.size(); ++idx) {
    threads[idx] = std::thread(&RecordLockTestFixture::TestThreadDeadlock, this,
                               op_groups[idx], std::ref(records));
  }

  // Wait till all threads finish
  for (auto& thread : threads) {
    thread.join();
  }
}
